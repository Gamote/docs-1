---
title: 'Validation, Computed Fields, and Custom Logic'
metaTitle: 'Validation, Computed Fields, Excluding Keys, and Wrapping the Client (Concepts)'
metaDescription: 'How to add validation, computed fields, and custom logic to applications using the Prisma Client'
tocDepth: 2
---

## Extending the Prisma Client

A common request we get is that while Prisma is great for working with the database, your data needs are far more complex. You need to be able to:

- **Validate** that the data that my user sent me is complete and valid
- Derive **computed fields** based on existing data
- **Exclude sensitive** **fields** that shouldn't be accessible to your users
- **Wrap the Prisma Client** to organize and group complex business logic.

Today you'll learn how to implement these patterns in your own application in a type-safe way.

We'll use the following schema to model a simplified SaaS app like Slack or Notion where each Team has many Users. We'll focus on an initial signup flow to illustrate these patterns.

```jsx
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int    @id @default(dbgenerated())
  email     String @unique
  password  String
  firstName String
  lastName  String
  Team      Team?  @relation(fields: [teamId], references: [id])
  teamId    Int?
}

model Team {
  id    Int    @id @default(dbgenerated())
  name  String @unique
  users User[]
}
```

## Creating a Helper Function

To kick things off, let's discuss how to abstract Prisma Client queries into functions. This will be used in the examples that follow.

Let's build a signup function that requires userÂ and team information to create rows in your database. We'll build this function first in Javascript then in Typescript.

### Helper Function in Javascript

In Javascript, that would look something like following:

```tsx
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// When you first signup, you create an initial user and a team of one
// with you as the first user.
async function signup(input) {
  const team = await prisma.team.create({
    data: {
      ...input.team,
      users: {
        create: input.user,
      },
    },
    include: {
      users: true,
    },
  })
  return team.users[0]
}

// Run the signup function
async function main() {
  const { team, user } = await signup({
    team: {
      name: 'Super Coffee',
    },
    user: {
      firstName: 'Alice',
      lastName: 'Wonderland',
      email: 'alice@prisma.io',
      password: 'everything is awesome',
    },
  })
}
```

### Helper Function in Typescript

The example above works, but it's not type-safe. You can call the signup function with any input. To make the example above type-safe, we'll utilize the exported types in `@prisma/client` along with some built-in types that Typescript provides.

```tsx highlight=5-9;normal
import { PrismaClient, Prisma, User, Team } from '@prisma/client'

const prisma = new PrismaClient()

type Signup = {
  // accept all team and user fields except id
  team: Omit<Prisma.TeamCreateArgs['data'], 'id'>
  user: Omit<Prisma.UserCreateArgs['data'], 'id'>
}

async function signup(input: Signup): Promise<User> {
  const team = await prisma.team.create({
    data: {
      ...input.team,
      users: {
        create: input.user,
      },
    },
    include: {
      users: true,
    },
  })
  return team.users[0]
}
```

In this example, you've linked the `Signup` input to the types in your database using `Prisma.TeamCreateArgs["data"]` and `Prisma.UserCreateArgs["data"]`. Then when the team or user fields change, your signup function will change with it.

This example also demonstrates how you can use the built-in `Omit` type to exclude fields from the input, further restraining what the signup function will accept.

## Validating User Input

Some data must be validated at runtime. For example, there's no way to type-check that your user's email contains an `@` symbol at build time. To ensure that the data you get is the data you expect, you can use runtime validation.

The Node.js ecosystem provides a number of high-quality, easy-to-use validation libraries you can choose from including: [joi](https://github.com/sideway/joi), [validator.js,](https://github.com/validatorjs/validator.js) [yup](https://github.com/jquense/yup) and [superstruct](https://github.com/ianstormtaylor/superstruct).

We'll go with superstruct for the example below. Let's extend your signup helper function to ensure that the data you get meets your expectation.

### Validating with Typescript and Superstruct

```tsx highlight=2,3,7-20,29-31;normal
import { PrismaClient, Prisma, User, Team } from '@prisma/client'
import { assert, object, string, size, refine } from 'superstruct'
import isEmail from 'isemail'

const prisma = new PrismaClient()

// Runtime validation
const Signup = object({
  team: object({
    name: size(string(), 2, 30),
  }),
  user: object({
    // string and an email
    email: refine(string(), 'email', (v) => isEmail.validate(v)),
    // password is between 7 and 30 characters long
    password: size(string(), 7, 30),
    firstName: size(string(), 2, 50),
    lastName: size(string(), 2, 50),
  }),
})

type Signup = {
  team: Omit<Prisma.TeamCreateArgs['data'], 'id'>
  user: Omit<Prisma.UserCreateArgs['data'], 'id'>
}

// Signup function
async function signup(input: Signup): Promise<User> {
  // Assert that input conforms to Signup, throwing with a helpful
  // error message if input is invalid.
  assert(input, Signup)
  const team = await prisma.team.create({
    data: {
      ...input.team,
      users: {
        create: input.user,
      },
    },
    include: {
      users: true,
    },
  })
  return team.users[0]
}
```

This example shows how you can easily add runtime validation to provide additionally check that the data we receive is the data we expect.

## Computed Fields

Another common pattern is computing a field that's derived from other data.

Let's say we also want to derive the user's full name from their first and last name. In the example below, you'll create a helper function to compute a full name from the first and last name stored in the database.

### Computing a Full Name in Javascript

Before you jump into complex type definitions, let's look at how you would accomplish this in Javascript with a `computeFullName` helper function

```jsx file=index.ts
function computeFullName(user) {
  return {
    ...user,
    fullName: user.firstName + ' ' + user.lastName,
  }
}

async function main() {
  const user = await prisma.user.findUnique({ where: 1 })
  const userWithFullName = computeFullName(user)
}
```

This function will simply tack on a `fullName` attribute to the user that's passed in.

### Computing a Full Name in Typescript

But how do you make this type-safe and flexible? With Typescript's rich type system, you can define a function that accepts a generic as an input then extend that generic to ensure it conforms to a specific structure. Finally you can return that generic with additional computed fields. Let's see how that might look:

```tsx file=index.ts highlight=1-5,7-10m,13-15;normal
// Define a type that needs a first and last name
type FirstLastName = {
  firstName: string
  lastName: string
}

// Extend the T generic with the fullName attribute
type WithFullName<T> = T & {
  fullName: string
}

// Take objects that satisfy FirstLastName and computes a full name
function computeFullName<User extends FirstLastName>(
  user: User
): WithFullName<User> {
  return {
    ...user,
    fullName: user.firstName + ' ' + user.lastName,
  }
}

async function main() {
  const user = await prisma.user.findUnique({ where: 1 })
  const userWithFullName = computeFullName(user)
}
```

In the example above, you've defined a `User` generic that extends the `FirstLastName` type. This means whatever you pass into `computeFullName` must contain `firstName` and `lastName` keys.

You've also defined a `WithFullName<User>` return type, which takes whatever `User` is and tacks on a `fullName` string attribute.

With your function, any object that contains `firstName` and `lastName` keys can compute a `fullName`. Pretty neat, right?

## Excluding **Sensitive** Fields

Very often, you don't want to include the **whole response** back from the database. In the signup function above, we've included the `password` in the response. Let's exclude this sensitive piece of data from the response.

### Exclude Password in Javascript

Once again, we'll start with Javascript so you can first focus on the logic. You first want to create an `exclude` helper function that takes a user and returns the user without certain fields:

```tsx file=index.ts
// Remove keys from user
function exclude(user, ...keys) {
  for (let key of keys) {
    delete user[key]
  }
  return user
}

function main() {
  const user = await prisma.user.findUnique({ where: 1 })
  const userWithoutPassword = exclude(user, 'password')
}
```

### Exclude Password in Typescript

Now let's make this `exclude` function type-safe. You first want to make sure that the keys you provide exist on the user and then you want to return a user that doesn't contain those keys.

Here's what that would look like in Typescript:

```tsx file=index.ts highlight=1-4;normal
function exclude<User, Key extends keyof User>(
  user: User,
  ...keys: Key[]
): Omit<User, Key> {
  for (let key of keys) {
    delete user[key]
  }
  return user
}

function main() {
  const user = await prisma.user.findUnique({ where: 1 })
  const userWithoutPassword = exclude(user, 'password')
}
```

In this example, we've provided two generics `User` and `Key`. The `Key` generic is defined as the keys of a `User` (e.g. email, password, firstName, etc.). These generics flow through the logic, returning a User that omits the list of keys provided.

## Organizing the Prisma Client **into Models**

In the examples above, you've created helper functions that weave the type-safety deeper through your application. Creating helper functions works well when your application is small, but as your application grows, you may find an inconsistent use of these helper functions strewn across your codebase.

One technique for consistently applying and organizing these helper functions is to group them in a class.

### Wrapping the Model in a Class

The most obvious way to wrap the Prisma Client is by wrapping it in a `Model` class:

```tsx highlight=4,23,28-30;normal
import { PrismaClient } from '@prisma/client'

class Model {
  constructor(private readonly model: PrismaClient['user']) {}

  /**
   * Signup the first user and create a new team of one. Return the User with
   * a full name and without a password
   */
  async signup(input: Signup) {
    assert(input, Signup)
    const team = await prisma.team.create({
      data: {
        ...input.team,
        users: {
          create: input.user,
        },
      },
      include: {
        users: true,
      },
    })
    return exclude(computeFullName(team.users[0]), 'password')
  }
}

async function main() {
  const prisma = new PrismaClient()
  const model = new Model(prisma.user)
  const user = await model.signup(/* { ... } */)
  console.log(user)
}
```

Here we're only exposing a `signup` method from the Prisma Client. With this approach, you'll no longer be able to call Prisma Client methods like findMany or upsert. This approach works well when you have a large application and you want to intentionally limit what your models can do.

### Extending the Prisma Client

But what if you don't want to hide existing functionality? In this case, you can use `Object.assign` to extend the Prisma Client without limiting it's functionality:

```tsx highlight=2,27-29;normal
function Model(model: PrismaClient['user']) {
  return Object.assign(model, {
    /**
     * Signup the first user and create a new team of one. Return the User with
     * a full name and without a password
     */
    async signup(input: Signup) {
      assert(input, Signup)
      const team = await prisma.team.create({
        data: {
          ...input.team,
          users: {
            create: input.user,
          },
        },
        include: {
          users: true,
        },
      })
      return exclude(computeFullName(team.users[0]), 'password')
    },
  })
}

async function main() {
  const prisma = new PrismaClient()
  const model = Model(prisma.user)
  const user = await model.signup(/* { ... } */)
  const numUsers = await model.count()
  console.log(user, numUsers)
}
```

Now you can use your custom `signup` method alongside `count`, `updateMany`, `groupBy` and all of the other wonderful methods that the Prisma Client provides. Best of all, it's all type-safe!

Keep in mind that the other methods like `findMany` or `findUnique`, will return users with a `password` and without a `fullName`. If you do go with this approach, you may want to override those functions to modify the results before returning them.

## Conclusion

Today we've shown how you can implement some patterns on top of the Prisma Client to extend functionality and cover your data needs.

Prisma does eventually plan to bake some of these features in but that shouldn't stop you from taking advantage of these patterns today. To see where we're headed with these features, follow along with these feature requests to learn more:

- [Exclude support](https://github.com/prisma/prisma/issues/5042)
- [Computed Fields](https://github.com/prisma/prisma/issues/3394)
- [Runtime Validation](https://github.com/prisma/prisma/issues/3528)

If you have further questions or concerns, please reach out to us either on [this Github Issue](https://github.com/prisma/prisma/issues/7161), a [Github discussion](https://github.com/prisma/prisma/discussions) or on [Slack](https://slack.prisma.io/).
